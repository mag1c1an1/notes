# ä¸ªäººçŽ¯å¢ƒæ­å»º 
### Arch Linux
```bash
$ sudo pacman -S riscv64-linux-gnu-binutils riscv64-linux-gnu-gcc riscv64-linux-gnu-gdb qemu-arch-extra
```

### Mac OS

```bash
$ xcode-select --install

$ brew tap riscv/riscv
$ brew install riscv-tools
$ PATH=$PATH:/usr/local/opt/riscv-gnu-toolchain/bin
$ brew install qemu
```

## è°ƒè¯•çŽ¯å¢ƒ
```bash
$ echo add-auto-load-safe-path /PATH/TO/xv6/.gdbinit >> $HOME/.gdbinit
```

æŽ¨èä½¿ç”¨linux

---

~~é¢å‘gradeç¼–ç¨‹ðŸ¤£~~
**ä»¥ä¸‹æ‰€æœ‰çš„ä»£ç ,éƒ½ä¸å¥å£®ï¼Œç”šè‡³è¿˜æœ‰bugï¼Œä»…ä»…åªæ˜¯åˆšåˆšå¥½èƒ½å¤Ÿè¿‡grade test.**  
I am using kitty in ubuntu 22.04, the system Chinese input method faling in kitty.  
So this note is just a practice for english writting (Chinese style).  
If the sub labs need to change many files, i will not post it . Bacasue I am lazy.  
If you have any futher questions , please contact me by email (mag1cian@icloud.com).

# Labs
## Lab Util
### sleep (easy)

æœ¬è´¨å°±æ˜¯ç†Ÿæ‚‰ä¸‹cï¼Œçœ‹çœ‹xv6æä¾›çš„å°åž‹cåº“ã€‚

```c
#include "user/user.h"
int main(int argc, char *argv[]) {
  if (argc == 1) {
    fprintf(2, "sleep arguments error");
  }
  int ticks  = atoi(argv[1]);
  sleep(ticks);
  exit(0);
}
```

### pingpong (easy)

å°±æ˜¯å¼€å­è¿›ç¨‹ï¼Œè®¾ç½®ç®¡é“é€šä¿¡ï¼Œæ³¨æ„fd[0]æ˜¯è¯»ï¼Œfd[1]æ˜¯å†™ã€‚ä½¿ç”¨å®Œæ¯•è¦closeï¼Œä¸ç„¶read å°±ä¼šé˜»å¡žç­‰å¾…ã€‚
```c
#include "user/user.h"
int main(int argc, char *argv[]) {
  // fork read pipe
  // p[0] for read p[1] for write
  int p[2];
  if (pipe(p) != 0) {
    fprintf(2, "pipe error");
    exit(1);
  }

  int pid = fork();
  if(pid > 0) {
    // parent
    // read
    char buf[1];
    write(p[1], buf, 1);
    close(p[1]);
    if(read(p[0],buf,1) != 1) {
      fprintf(2, "parent read error ");
      exit(1);
    }
    pid = getpid();
    printf("%d: received pong\n",pid);
  }else if (pid == 0) {
    // child
    char buf[1];
    if(read(p[0],buf,1) != 1) {
      fprintf(2, "child read error ");
      exit(1);
    }
    close(p[0]);
    pid = getpid();
    printf("%d: received ping\n",pid);
    write(p[1],buf,1);
    close(p[1]);
  }else {
    //error
    fprintf(2, "fork error");
  }
  exit(0);
}
```

### primes (moderate)

ç”¨è¿›ç¨‹æ¨¡æ‹Ÿç´ æ•°ç­›æ³•ï¼ŒæŠŠä¸èƒ½æ•´é™¤çš„å‘é€ç»™å­©å­ã€‚
ä¸èƒ½è®¾ç½®rightï¼Œleftä¸ºå…¨å±€å˜é‡,ä¹‹åŽå­©å­è°ƒç”¨pipe,ä¼šè¦†ç›–parentçš„fd.

```c
#include "user/user.h"

void set_pipe(int *, int *);

// åªæœ‰childä¼šè¿›å…¥è¿™ä¸ªå‡½æ•°ï¼Œæ ¹æ®éœ€è¦ç»§ç»­è°ƒç”¨set_pipe
void core_thing(int *left) {
  int p;
  int status = 0;
  int right[2];
  read(left[0], &p, 4);
  printf("prime %d\n",p);
  while (1) {
    int n;
    if (read(left[0],&n,4) == 0)
    {
      break;
    }
    if (n % p != 0) {
      if (status == 0)
        set_pipe(&status, right);
      write(right[1], &n, 4);
    }
  }
  close(left[0]);
  if(status == 1)
  {
    close(right[1]);
  }
  wait(0);
  exit(0);
}

// è®¾ç½®ç®¡é“å¯¹äºŽcalleræ¥è¯´å°±æ˜¯å‘å³è®¾ç½®,child è°ƒç”¨ core_thing æ°¸ä¸è¿”å›ž, parent è¿”å›ž

void set_pipe(int *status, int *direction) {
  pipe(direction);
  int pid = fork();
  if (pid > 0) {
    // parent just need to send numbers
    close(direction[0]);
    *status = 1;
  } else if (pid == 0) {
    // child just need to read from his parent
    close(direction[1]);
    *status = 0;
    core_thing(direction);
  } else {
    fprintf(2, "fork error\n");
    exit(1);
  }
}

int main(int argc, char *argv[]) {
  int status = 0;
  int right[2];
  for (int i = 2; i <= 35; i++) {
    if (status == 0) {
      set_pipe(&status, right);
    }
    write(right[1], &i, 4);
  }
  close(right[1]);
  wait(0);
  exit(0);
}
```

### find (moderate)

æŠ„ä¸‹`user/ls.c` çš„ä»£ç æ”¹æ”¹,æ³¨æ„è·³è¿‡`inum`ä¸º0çš„æƒ…å†µ.
```c
#include "user/user.h"

#include "kernel/fs.h"

#include "kernel/stat.h"

char *filename = (char *)0;

void find(char *path) {
  char buf[512], *p;
  int fd;
  struct dirent de;
  struct stat st;
  fd = open(path, 0);
  strcpy(buf, path);
  p = buf + strlen(buf);
  *p++ = '/';
  while (read(fd, &de, sizeof(de)) == sizeof(de)) {
    if (de.inum == 0)
      continue;
    memmove(p, de.name, DIRSIZ);
    p[DIRSIZ] = 0;
    stat(buf, &st);
    switch (st.type) {
    case T_FILE:
      if (strcmp(p, filename) == 0)
        fprintf(1,"%s\n", buf);
      break;
    case T_DIR:
      if (strcmp(p, ".") == 0 || strcmp(p, "..") == 0)
        break;
      find(buf);
      break;
    default:
      break;
    }
  }
}

int main(int argc, char *argv[]) {
  if (argc < 3) {
    fprintf(2, "arguments error\n");
    exit(1);
  }
  filename = argv[2];

  find(argv[1]);
  exit(0);
}
```

### xargs (moderate)

ä»¥'\n'ä¸ºåˆ†å‰²ç¬¦
```c
#include "user/user.h"

#include "kernel/param.h"

void execcmd(char *cmd, char *args[]) {
  int pid = fork();
  if (pid > 0) {
    // parent
    wait(0);
  } else if (pid == 0) {
    //  child
    exec(cmd, args);
    exit(1);
  } else {
    fprintf(2, "fork error\n");
    exit(1);
  }
}

int main(int argc, char *argv[]) {
  char buf[512];
  char *cmdargs[MAXARG];
  char *p;
  int len = argc - 1;
  for (int i = 1; i < argc; i++) {
    cmdargs[i - 1] = argv[i];
  }
  while (*(p = gets(buf, sizeof(buf))) != '\0') {
    int i;
    for (i = 0;; i++) {
      if (p[i] == '\n' || p[i] == '\0')
        break;
    }
    p[i] = '\0';
    cmdargs[len] = p;
    cmdargs[len + 1] = 0;
    execcmd(argv[1],cmdargs);
  }
  exit(0);
}
```

### Optional challenge exercises
  - [ ] Write an uptime program that prints the uptime in terms of ticks using the uptime system call. (easy)
  - [ ] Support regular expressions in name matching for find. grep.c has some primitive support for regular expressions. (easy)
  - [ ] The xv6 shell (user/sh.c) is just another user program and you can improve it. It is a minimal shell and lacks many features found in real shell. For example, modify the shell to not print a $ when processing shell commands from a file (moderate), modify the shell to support wait (easy), modify the shell to support lists of commands, separated by ";" (moderate), modify the shell to support sub-shells by implementing "(" and ")" (moderate), modify the shell to support tab completion (easy), modify the shell to keep a history of passed shell commands (moderate), or anything else you would like your shell to do. (If you are very ambitious, you may have to modify the kernel to support the kernel features you need; xv6 doesn't support much.) 




## Lab: system call
pay attention to xv6 syscall apis like argint() argaddr()
### System call tracing (moderate)
add a if sentence.
### Sysinfo (moderate)
use myproc()
### Optional challenge exercises
- [ ] Print the system call arguments for traced system calls (easy).
- [ ] Compute the load average and export it through sysinfo(moderate).


## Lab: page tables
### Speed up system calls (easy)
æœ¬è´¨å°±æ˜¯ç»™ç”¨æˆ·æ˜ å°„ä¸€ä¸ªç‰©ç†é¡µ,å½“ç„¶é¦–å…ˆå†…æ ¸å…ˆè¦åˆ†é…è¿™ä¸€é¡µ,å…³é”®æ˜¯æ³¨æ„free
### Q1
> Which other xv6 system call(s) could be made faster using this shared page? Explain how. 
uptime
## Print a page table (easy)
dfs 

### Q2
> Explain the output of vmprint in terms of Fig 3-4 from the text. What does page 0 contain? What is in page 2? When running in user mode, could the process read/write the memory mapped by page 1? What does the third to last page contain? 
data and text,stack, no, trampoline page, trapframe page.
### Detecting which pages have been accessed (hard)
use bit operation.
find a flag in pte and clean it.
### Optional challenge exercises
 - [ ] Use super-pages to reduce the number of PTEs in page tables.
 - [ ] Unmap the first page of a user process so that dereferencing a null pointer will result in a fault. You will have to start the user text segment at, for example, 4096, instead of 0.
 - [ ] Add a system call that reports dirty pages (modified pages) using PTE_D. 

## Lab: traps
### RISC-V assembly (easy)
#### Q1
see riscv calling convention  
 a0 ~ a7, a2
#### Q2
all inlined  
 0x26, 0x26 
#### Q3
serach or compute  
 0x628
#### Q4
according to RISC-V spec (Vol I), jalr will store pc+4 in ra(x1), or just see the `rd` subfield in the binary code  
 0x38
#### Q5
 HE110 World ,0x726c64,no
#### Q6
 $a2, due to mismatch,printf will find the third argument. 

### Backtrace (moderate)
pay attention to pointer computation
```c
void backtrace() {
  printf("backtrace:\n");
  uint64* fp;
  uint64* ra;
  fp = (uint64*)r_fp();
  ra = fp - 1;
  uint64* end =(uint64 *) PGROUNDUP((uint64)fp);
  while(end != fp)
    {
      printf("%p\n",*ra);
      fp = (uint64*)*(fp-2);
      ra = fp-1;
    }
}
```
### Alarm (hard)
I save all the general registers. And pay attention to myproc()->trapframe->epc. 
```c 
  // kernel/trap.c
  if (which_dev == 2) {
    if (p->hflag) {
      p->pticks += 1;
      if (p->pticks == p->interval) {
        if (p->aentry) {
          memmove(&p->tmp, p->trapframe, sizeof(struct trapframe));
          p->pticks = 0;
          p->trapframe->epc = p->fn;
          p->aentry = 0;
        }else {
          p->pticks -=1 ;
        }
      }
    }
    // give up the CPU if this is a timer interrupt.
    yield();
  }
```
```c
// kernel/sysproc.c
uint64 sys_sigalarm(void) {
  int n;
  uint64 addr;
  struct proc *p = myproc();
  if (argint(0, &n) < 0)
    return -1;
  if (argaddr(1, &addr) < 0)
    return -1;
  p->interval = n;
  p->fn = addr;
  p->hflag = (n == 0 && addr == 0)? 0:1;
  p->pticks = 0;
  return 0;
}
uint64 sys_sigreturn(void) { 
  struct proc *p = myproc();
  p->aentry = 1;
  p->trapframe->epc = p->tmp.epc;
  p->trapframe->ra = p->tmp.ra;
  p->trapframe->sp = p->tmp.sp;
  p->trapframe->gp = p->tmp.gp;
  p->trapframe->tp = p->tmp.tp;
  p->trapframe->t0 = p->tmp.t0;
  p->trapframe->t1 = p->tmp.t1;
  p->trapframe->t2 = p->tmp.t2;
  p->trapframe->t3 = p->tmp.t3;
  p->trapframe->t4 = p->tmp.t4;
  p->trapframe->t5 = p->tmp.t5;
  p->trapframe->t6 = p->tmp.t6;
  p->trapframe->a0 = p->tmp.a0;
  p->trapframe->a1 = p->tmp.a1;
  p->trapframe->a2 = p->tmp.a2;
  p->trapframe->a3 = p->tmp.a3;
  p->trapframe->a4 = p->tmp.a4;
  p->trapframe->a5 = p->tmp.a5;
  p->trapframe->a6 = p->tmp.a6;
  p->trapframe->a7 = p->tmp.a7;
  p->trapframe->s0 = p->tmp.s0;
  p->trapframe->s1 = p->tmp.s1;
  p->trapframe->s2 = p->tmp.s2;
  p->trapframe->s3 = p->tmp.s3;
  p->trapframe->s4 = p->tmp.s4;
  p->trapframe->s5 = p->tmp.s5;
  p->trapframe->s6 = p->tmp.s6;
  p->trapframe->s7 = p->tmp.s7;
  p->trapframe->s8 = p->tmp.s8;
  p->trapframe->s9 = p->tmp.s9;
  p->trapframe->s10 = p->tmp.s10;
  p->trapframe->s11= p->tmp.s11;
  return 0;
}
```

Optional challenge exercises
 - [ ] Print the names of the functions and line numbers in backtrace() instead of numerical addresses (hard).


### Lab: Copy-on-Write Fork for xv6
Handle COW page fault, use riscv reserve bits to indicate a COW page.  
In riscv , there are three kinds of page fault, instruction page fault, store page fault and load page fault, but we just need to focus on store page fault. Because we change pte's write flag. Add a global page reference count array.Make sure that when a page allocate or fork to increase its ref count,and decrease that when it be dropped. In copyout, see a page whether it is a COW page.

some piece of code:
```c
  } else if (r_scause() == 15) {
    uint64 va = r_stval();
    // printf("handle page fault by va %p\n", va);
    if(va>=MAXVA)
      goto bad;
    pte_t *pte = walk(p->pagetable, va, 0);
    uint flags = PTE_FLAGS(*pte);
    if (flags & PTE_C) {
      // cow
      char *mem;
      if ((mem = kalloc()) == 0) {
        // printf("no free physcial memory\n");
        goto bad;
      }
      uint64 pa = PTE2PA(*pte);            
      memmove((void *)mem,(void*)pa,PGSIZE);
      flags = (flags | PTE_W) & ~PTE_C;      
      *pte = PA2PTE(mem) | flags;
      // free old page
      kfree((void*)pa); 
    } else {
      printf("not a cow page fault\n");
      bad:
      p->killed = 1;
    }
```

Optional challenge exercises
- [ ] Measure how much your COW implementation reduces the number of bytes xv6 copies and the number of physical pages it allocates. Find and exploit opportunities to further reduce those numbers. 
- [ ] Modify xv6 to support both lazy page allocation and COW.
