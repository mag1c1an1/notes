# ä¸ªäººçŽ¯å¢ƒæ­å»º 
### Arch Linux
```bash
$ sudo pacman -S riscv64-linux-gnu-binutils riscv64-linux-gnu-gcc riscv64-linux-gnu-gdb qemu-arch-extra
```

### Mac OS

```bash
$ xcode-select --install

$ brew tap riscv/riscv
$ brew install riscv-tools
$ PATH=$PATH:/usr/local/opt/riscv-gnu-toolchain/bin
$ brew install qemu
```

## è°ƒè¯•çŽ¯å¢ƒ
```bash
$ echo add-auto-load-safe-path /PATH/TO/xv6/.gdbinit >> $HOME/.gdbinit
```

æŽ¨èä½¿ç”¨linux


# Labs
## Lab Util
~~é¢å‘gradeç¼–ç¨‹ðŸ¤£~~
**ä»¥ä¸‹æ‰€æœ‰çš„ä»£ç ,éƒ½ä¸å¥å£®ï¼Œç”šè‡³è¿˜æœ‰bugï¼Œä»…ä»…åªæ˜¯åˆšåˆšå¥½èƒ½å¤Ÿè¿‡grade test.**

### sleep (easy)

æœ¬è´¨å°±æ˜¯ç†Ÿæ‚‰ä¸‹cï¼Œçœ‹çœ‹xv6æä¾›çš„å°åž‹cåº“ã€‚

```c
#include "user/user.h"
int main(int argc, char *argv[]) {
  if (argc == 1) {
    fprintf(2, "sleep arguments error");
  }
  int ticks  = atoi(argv[1]);
  sleep(ticks);
  exit(0);
}
```

### pingpong (easy)

å°±æ˜¯å¼€å­è¿›ç¨‹ï¼Œè®¾ç½®ç®¡é“é€šä¿¡ï¼Œæ³¨æ„fd[0]æ˜¯è¯»ï¼Œfd[1]æ˜¯å†™ã€‚ä½¿ç”¨å®Œæ¯•è¦closeï¼Œä¸ç„¶read å°±ä¼šé˜»å¡žç­‰å¾…ã€‚
```c
#include "user/user.h"
int main(int argc, char *argv[]) {
  // fork read pipe
  // p[0] for read p[1] for write
  int p[2];
  if (pipe(p) != 0) {
    fprintf(2, "pipe error");
    exit(1);
  }

  int pid = fork();
  if(pid > 0) {
    // parent
    // read
    char buf[1];
    write(p[1], buf, 1);
    close(p[1]);
    if(read(p[0],buf,1) != 1) {
      fprintf(2, "parent read error ");
      exit(1);
    }
    pid = getpid();
    printf("%d: received pong\n",pid);
  }else if (pid == 0) {
    // child
    char buf[1];
    if(read(p[0],buf,1) != 1) {
      fprintf(2, "child read error ");
      exit(1);
    }
    close(p[0]);
    pid = getpid();
    printf("%d: received ping\n",pid);
    write(p[1],buf,1);
    close(p[1]);
  }else {
    //error
    fprintf(2, "fork error");
  }
  exit(0);
}
```

### primes (moderate)

ç”¨è¿›ç¨‹æ¨¡æ‹Ÿç´ æ•°ç­›æ³•ï¼ŒæŠŠä¸èƒ½æ•´é™¤çš„å‘é€ç»™å­©å­ã€‚
ä¸èƒ½è®¾ç½®rightï¼Œleftä¸ºå…¨å±€å˜é‡,ä¹‹åŽå­©å­è°ƒç”¨pipe,ä¼šè¦†ç›–parentçš„fd.

```c
#include "user/user.h"

void set_pipe(int *, int *);

// åªæœ‰childä¼šè¿›å…¥è¿™ä¸ªå‡½æ•°ï¼Œæ ¹æ®éœ€è¦ç»§ç»­è°ƒç”¨set_pipe
void core_thing(int *left) {
  int p;
  int status = 0;
  int right[2];
  read(left[0], &p, 4);
  printf("prime %d\n",p);
  while (1) {
    int n;
    if (read(left[0],&n,4) == 0)
    {
      break;
    }
    if (n % p != 0) {
      if (status == 0)
        set_pipe(&status, right);
      write(right[1], &n, 4);
    }
  }
  close(left[0]);
  if(status == 1)
  {
    close(right[1]);
  }
  wait(0);
  exit(0);
}

// è®¾ç½®ç®¡é“å¯¹äºŽcalleræ¥è¯´å°±æ˜¯å‘å³è®¾ç½®,child è°ƒç”¨ core_thing æ°¸ä¸è¿”å›ž, parent è¿”å›ž

void set_pipe(int *status, int *direction) {
  pipe(direction);
  int pid = fork();
  if (pid > 0) {
    // parent just need to send numbers
    close(direction[0]);
    *status = 1;
  } else if (pid == 0) {
    // child just need to read from his parent
    close(direction[1]);
    *status = 0;
    core_thing(direction);
  } else {
    fprintf(2, "fork error\n");
    exit(1);
  }
}

int main(int argc, char *argv[]) {
  int status = 0;
  int right[2];
  for (int i = 2; i <= 35; i++) {
    if (status == 0) {
      set_pipe(&status, right);
    }
    write(right[1], &i, 4);
  }
  close(right[1]);
  wait(0);
  exit(0);
}
```

### find (moderate)

æŠ„ä¸‹`user/ls.c` çš„ä»£ç æ”¹æ”¹,æ³¨æ„è·³è¿‡`inum`ä¸º0çš„æƒ…å†µ.
```c
#include "user/user.h"

#include "kernel/fs.h"

#include "kernel/stat.h"

char *filename = (char *)0;

void find(char *path) {
  char buf[512], *p;
  int fd;
  struct dirent de;
  struct stat st;
  fd = open(path, 0);
  strcpy(buf, path);
  p = buf + strlen(buf);
  *p++ = '/';
  while (read(fd, &de, sizeof(de)) == sizeof(de)) {
    if (de.inum == 0)
      continue;
    memmove(p, de.name, DIRSIZ);
    p[DIRSIZ] = 0;
    stat(buf, &st);
    switch (st.type) {
    case T_FILE:
      if (strcmp(p, filename) == 0)
        fprintf(1,"%s\n", buf);
      break;
    case T_DIR:
      if (strcmp(p, ".") == 0 || strcmp(p, "..") == 0)
        break;
      find(buf);
      break;
    default:
      break;
    }
  }
}

int main(int argc, char *argv[]) {
  if (argc < 3) {
    fprintf(2, "arguments error\n");
    exit(1);
  }
  filename = argv[2];

  find(argv[1]);
  exit(0);
}
```

### xargs (moderate)

ä»¥'\n'ä¸ºåˆ†å‰²ç¬¦
```c
#include "user/user.h"

#include "kernel/param.h"

void execcmd(char *cmd, char *args[]) {
  int pid = fork();
  if (pid > 0) {
    // parent
    wait(0);
  } else if (pid == 0) {
    //  child
    exec(cmd, args);
    exit(1);
  } else {
    fprintf(2, "fork error\n");
    exit(1);
  }
}

int main(int argc, char *argv[]) {
  char buf[512];
  char *cmdargs[MAXARG];
  char *p;
  int len = argc - 1;
  for (int i = 1; i < argc; i++) {
    cmdargs[i - 1] = argv[i];
  }
  while (*(p = gets(buf, sizeof(buf))) != '\0') {
    int i;
    for (i = 0;; i++) {
      if (p[i] == '\n' || p[i] == '\0')
        break;
    }
    p[i] = '\0';
    cmdargs[len] = p;
    cmdargs[len + 1] = 0;
    execcmd(argv[1],cmdargs);
  }
  exit(0);
}
```

### Optional challenge exercises
  * Write an uptime program that prints the uptime in terms of ticks using the uptime system call. (easy)
  * Support regular expressions in name matching for find. grep.c has some primitive support for regular expressions. (easy)
  * The xv6 shell (user/sh.c) is just another user program and you can improve it. It is a minimal shell and lacks many features found in real shell. For example, modify the shell to not print a $ when processing shell commands from a file (moderate), modify the shell to support wait (easy), modify the shell to support lists of commands, separated by ";" (moderate), modify the shell to support sub-shells by implementing "(" and ")" (moderate), modify the shell to support tab completion (easy), modify the shell to keep a history of passed shell commands (moderate), or anything else you would like your shell to do. (If you are very ambitious, you may have to modify the kernel to support the kernel features you need; xv6 doesn't support much.) 




## Lab: system call
pay attention to xv6 syscall apis like argint() argaddr()
### System call tracing (moderate)
add a if sentence.
### Sysinfo (moderate)
use myproc()
### Optional challenge exercises
* Print the system call arguments for traced system calls (easy).
* Compute the load average and export it through sysinfo(moderate).


## Lab: page tables
### Speed up system calls (easy)
æœ¬è´¨å°±æ˜¯ç»™ç”¨æˆ·æ˜ å°„ä¸€ä¸ªç‰©ç†é¡µ,å½“ç„¶é¦–å…ˆå†…æ ¸å…ˆè¦åˆ†é…è¿™ä¸€é¡µ,å…³é”®æ˜¯æ³¨æ„free
### Q1
> Which other xv6 system call(s) could be made faster using this shared page? Explain how. 
sys_read, kernel can map a file.
## Print a page table (easy)
dfs 

### Q2
> Explain the output of vmprint in terms of Fig 3-4 from the text. What does page 0 contain? What is in page 2? When running in user mode, could the process read/write the memory mapped by page 1? What does the third to last page contain? 
data and text,stack, no, trampoline page, trapframe page.
### Detecting which pages have been accessed (hard)
use bit operation.
find a flag in pte and clean it.
### Optional challenge exercises
 * Use super-pages to reduce the number of PTEs in page tables.
 * Unmap the first page of a user process so that dereferencing a null pointer will result in a fault. You will have to start the user text segment at, for example, 4096, instead of 0.
 * Add a system call that reports dirty pages (modified pages) using PTE_D. 
