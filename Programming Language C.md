### 预处理的步骤
把用'\\'字符续行的多行代码接成一行
```c
#define STR "hello, "\
		"world"
```
这种续行的写法要求\后面紧跟换行，中间不能有其它空白字符

一条预处理指示由一个逻辑代码行组成，以#开头，后面跟若干个预处理Token，在预处理指示中允许使用的空白字符只有空格和Tab。

#### 函数式宏定义
1、函数式宏定义的参数没有类型，预处理器只负责做形式上的替换，而不做参数类型检查，所以传参时要格外小心
2、调用真正函数的代码和调用函数式宏定义的代码编译生成的指令不同。如果MAX是个真正的函数，那么它的函数体return a > b ? a : b;要编译生成指令，代码中出现的每次调用也要编译生成传参指令和call指令。而如果MAX是个函数式宏定义，这个宏定义本身倒不必编译生成指令，但是代码中出现的每次调用编译生成的指令都相当于一个函数体，而不是简单的几条传参指令和call指令。所以，使用函数式宏定义编译生成的目标文件会比较大。

函数式宏定义经常写成这样的形式（取自内核代码include/linux/pm.h）：
```c
#define device_init_wakeup(dev,val) \
        do { \
                device_can_wakeup(dev) = !!(val); \
                device_set_wakeup_enable(dev,val); \
        } while(0)
```
问题出在device_init_wakeup(d, v);末尾的;号，如果不允许写这个;号，看起来不像个函数调用，可如果写了这个;号，宏展开之后就有语法错误，if语句被这个;号结束掉了，没法跟else配对。因此，do { ... } while(0)是一种比较好的解决办法。
####   # , ##运算符和可变参数

在函数式宏定义中，#运算符用于创建字符串，#运算符后面应该跟一个形参（中间可以有空格或Tab），例如：
```c
#define STR(s) # s
STR(hello 	world)
```
用cpp命令预处理之后是"hello␣world"，自动用"号把实参括起来成为一个字符串，并且实参中的连续多个空白字符被替换成一个空格。

注意如果实参中包含字符常量或字符串，则宏展开之后字符串的界定符"要替换成\"，字符常量或字符串中的\和"字符要替换成\\和\"。

在宏定义中可以用##运算符把前后两个预处理Token连接成一个预处理Token，和#运算符不同，##运算符不仅限于函数式宏定义，变量式宏定义也可以用

函数式宏定义也可以带可变参数，同样是在参数列表中用...表示可变参数
```c
#define showlist(...) printf(#__VA_ARGS__)
#define report(test, ...) ((test)?printf(#test):\
	printf(__VA_ARGS__))
showlist(The first, second, and third items.);
report(x>y, "x is %d but y is %d", x, y);
```
在宏定义中，可变参数的部分用 **\_\_VA_ARGS\_\_** 表示，实参中对应...的几个参数可以看成一个参数替换到宏定义中*\_\_VA_ARGS\_\_*所在的地方。

gcc有一种扩展语法，如果##运算符用在 **\_\_VA_ARGS\_\_** 前面，除了起连接作用之外还有特殊的含义

当__VA_ARGS是空参数时，##运算符把它前面的 **,** 号“吃”掉了.



